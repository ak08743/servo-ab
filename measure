#!/usr/bin/env python3

from measure import Measure, ST_FAILED

import sys
import os
import time
import subprocess
import re
import json
import csv
import statistics

from jinja2 import Template

from threading import Timer

DESC = "Locust limited measure driver for Opsani Optune"
VERSION = "0.0.1"
HAS_CANCEL = False
PROGRESS_INTERVAL = 30

DFLT_LOAD_CFG = {
    'n_clients': 2000,        # Number of simultaneous clients
    'hatch_rate': 200,        # Clients hatch rate (# of clients per second added till n_clients is reached
    'n_requests': 10000000,  # request limit
    't_limit': 180,           # time limit in seconds:   0 => no time limit
    'client_min_wait': 100,   # Min wait time between requests for client
    'client_max_wait': 1000   # Max wait time between requests for client
}

METRICS = {
    'clients_concurrency': {'unit': 'count'},
    'clients_min_delay': {'unit': 'milliseconds'},
    'clients_max_delay': {'unit': 'milliseconds'},
    'get_root_requests_total': {'unit': 'count'},
    'get_root_requests_failures': {'unit': 'count'},
    'get_root_requests_median_response_time': {'unit': 'milliseconds'},
    'get_root_requests_average_response_time': {'unit': 'milliseconds'},
    'get_root_requests_minimum_response_time': {'unit': 'milliseconds'},
    'get_root_requests_maximum_response_time': {'unit': 'milliseconds'},
    'get_root_requests_rps': {'unit': 'requests/second'},
    'get_cart_requests_total': {'unit': 'count'},
    'get_cart_requests_failures': {'unit': 'count'},
    'get_cart_requests_median_response_time': {'unit': 'milliseconds'},
    'get_cart_requests_average_response_time': {'unit': 'milliseconds'},
    'get_cart_requests_minimum_response_time': {'unit': 'milliseconds'},
    'get_cart_requests_maximum_response_time': {'unit': 'milliseconds'},
    'get_cart_requests_rps': {'unit': 'requests/second'},
    'post_cart_requests_total': {'unit': 'count'},
    'post_cart_requests_failures': {'unit': 'count'},
    'post_cart_requests_median_response_time': {'unit': 'milliseconds'},
    'post_cart_requests_average_response_time': {'unit': 'milliseconds'},
    'post_cart_requests_minimum_response_time': {'unit': 'milliseconds'},
    'post_cart_requests_maximum_response_time': {'unit': 'milliseconds'},
    'post_cart_requests_rps': {'unit': 'requests/second'},
    'get_products_requests_total': {'unit': 'count'},
    'get_products_requests_failures': {'unit': 'count'},
    'get_products_requests_median_response_time': {'unit': 'milliseconds'},
    'get_products_requests_average_response_time': {'unit': 'milliseconds'},
    'get_products_requests_minimum_response_time': {'unit': 'milliseconds'},
    'get_products_requests_maximum_response_time': {'unit': 'milliseconds'},
    'get_products_requests_rps': {'unit': 'requests/second'},
    'post_setcurrency_requests_total': {'unit': 'count'},
    'post_setcurrency_requests_failures': {'unit': 'count'},
    'post_setcurrency_requests_median_response_time': {'unit': 'milliseconds'},
    'post_setcurrency_requests_average_response_time': {'unit': 'milliseconds'},
    'post_setcurrency_requests_minimum_response_time': {'unit': 'milliseconds'},
    'post_setcurrency_requests_maximum_response_time': {'unit': 'milliseconds'},
    'post_setcurrency_requests_rps': {'unit': 'requests/second'},
    'total_requests_total': {'unit': 'count'},
    'total_requests_failures': {'unit': 'count'},
    'total_requests_median_response_time': {'unit': 'milliseconds'},
    'total_requests_average_response_time': {'unit': 'milliseconds'},
    'total_requests_minimum_response_time': {'unit': 'milliseconds'},
    'total_requests_maximum_response_time': {'unit': 'milliseconds'},
    'total_requests_rps': {'unit': 'requests/second'},
    'get_root_percentile_50': {'unit': 'millisecond'},
    'get_root_percentile_66': {'unit': 'millisecond'},
    'get_root_percentile_75': {'unit': 'millisecond'},
    'get_root_percentile_80': {'unit': 'millisecond'},
    'get_root_percentile_90': {'unit': 'millisecond'},
    'get_root_percentile_95': {'unit': 'millisecond'},
    'get_root_percentile_98': {'unit': 'millisecond'},
    'get_root_percentile_99': {'unit': 'millisecond'},
    'get_root_percentile_100': {'unit': 'millisecond'},
    'get_cart_percentile_50': {'unit': 'millisecond'},
    'get_cart_percentile_66': {'unit': 'millisecond'},
    'get_cart_percentile_75': {'unit': 'millisecond'},
    'get_cart_percentile_80': {'unit': 'millisecond'},
    'get_cart_percentile_90': {'unit': 'millisecond'},
    'get_cart_percentile_95': {'unit': 'millisecond'},
    'get_cart_percentile_98': {'unit': 'millisecond'},
    'get_cart_percentile_99': {'unit': 'millisecond'},
    'get_cart_percentile_100': {'unit': 'millisecond'},
    'post_cart_percentile_50': {'unit': 'millisecond'},
    'post_cart_percentile_66': {'unit': 'millisecond'},
    'post_cart_percentile_75': {'unit': 'millisecond'},
    'post_cart_percentile_80': {'unit': 'millisecond'},
    'post_cart_percentile_90': {'unit': 'millisecond'},
    'post_cart_percentile_95': {'unit': 'millisecond'},
    'post_cart_percentile_98': {'unit': 'millisecond'},
    'post_cart_percentile_99': {'unit': 'millisecond'},
    'post_cart_percentile_100': {'unit': 'millisecond'},
    'post_checkout_percentile_50': {'unit': 'millisecond'},
    'post_checkout_percentile_66': {'unit': 'millisecond'},
    'post_checkout_percentile_75': {'unit': 'millisecond'},
    'post_checkout_percentile_80': {'unit': 'millisecond'},
    'post_checkout_percentile_90': {'unit': 'millisecond'},
    'post_checkout_percentile_95': {'unit': 'millisecond'},
    'post_checkout_percentile_98': {'unit': 'millisecond'},
    'post_checkout_percentile_99': {'unit': 'millisecond'},
    'post_checkout_percentile_100': {'unit': 'millisecond'},
    'get_products_percentile_50': {'unit': 'millisecond'},
    'get_products_percentile_66': {'unit': 'millisecond'},
    'get_products_percentile_75': {'unit': 'millisecond'},
    'get_products_percentile_80': {'unit': 'millisecond'},
    'get_products_percentile_90': {'unit': 'millisecond'},
    'get_products_percentile_95': {'unit': 'millisecond'},
    'get_products_percentile_98': {'unit': 'millisecond'},
    'get_products_percentile_99': {'unit': 'millisecond'},
    'get_products_percentile_100': {'unit': 'millisecond'},
    'post_setcurrency_percentile_50': {'unit': 'millisecond'},
    'post_setcurrency_percentile_66': {'unit': 'millisecond'},
    'post_setcurrency_percentile_75': {'unit': 'millisecond'},
    'post_setcurrency_percentile_80': {'unit': 'millisecond'},
    'post_setcurrency_percentile_90': {'unit': 'millisecond'},
    'post_setcurrency_percentile_95': {'unit': 'millisecond'},
    'post_setcurrency_percentile_98': {'unit': 'millisecond'},
    'post_setcurrency_percentile_99': {'unit': 'millisecond'},
    'post_setcurrency_percentile_100': {'unit': 'millisecond'},
    'total_percentile_50': {'unit': 'millisecond'},
    'total_percentile_66': {'unit': 'millisecond'},
    'total_percentile_75': {'unit': 'millisecond'},
    'total_percentile_80': {'unit': 'millisecond'},
    'total_percentile_90': {'unit': 'millisecond'},
    'total_percentile_95': {'unit': 'millisecond'},
    'total_percentile_98': {'unit': 'millisecond'},
    'total_percentile_99': {'unit': 'millisecond'},
    'total_percentile_100': {'unit': 'millisecond'}
}

METRICS_MAP = {
    'GET /': 'get_root',
    'GET /cart': 'get_cart',
    'POST /cart': 'post_cart',
    'POST /cart/checkout': 'post_checkout',
    'POST /setCurrency': 'post_setcurrency',
    'Total': 'total'
}

PERCENTILE_LIST = ['100', '50', '66', '75', '80', '90', '95', '98', '99']
COUNTERS_MAP = {
    'average_response_time': 'Average response time',
    'failures': '# failures',
    'maximum_response_time': 'Max response time',
    'median_response_time': 'Median response time',
    'minimum_response_time': 'Min response time',
    'rps': 'Requests/s',
    'total': '# requests'}

class L(Measure):
    # def __init__(self, version, cli_desc, supports_cancel, progress_interval):
    #     super().__init__(version, cli_desc, supports_cancel, progress_interval)

    # overwrites super
    def describe(self):
        return METRICS

    # overwrites super
    def handle_cancel(self, signal, frame):
        err = "Exiting due to signal: %s"%signal
        self.print_measure_error(err, ST_FAILED)
        try:
            self.proc.terminate()
        except:
            pass
        sys.exit(3)

    # overwrites super
    def measure(self):
        load_cfg = DFLT_LOAD_CFG.copy()
        try:
            load = self.input_data.get('control', {}).get('load', {})
        except:
            raise Exception('Invalid control configuration format in input')

        # update the config dictionary with the test URL
        load_cfg['test_url'] = 'http://' + os.environ.get('FRONTEND_ADDR', 'frontend:80')
        # update the config dictionary with any headers, split into a list on comma
        # if os.environ.get('AB_HEADERS'):
        #     load_cfg['headers'] = json.loads(os.environ.get('AB_HEADERS'))
        load_cfg.update(load) # will override test_url and headers if provided in load
        if not load_cfg['test_url']:
            raise Exception('Load configuration is missing a test_url')

        # Generate locust file here from template
        self._generate_locust_config(load_cfg)

        result, command = self._run_locust(
            test_url      = load_cfg['test_url'],
            test_scenario = 'locustfile.py',
            n_clients     = load_cfg['n_clients'],
            hatch_rate    = load_cfg['hatch_rate'],
            n_requests    = load_cfg['n_requests'],
            t_limit       = load_cfg['t_limit']
            )

        _metrics = {
            'clients_concurrency': load_cfg['n_clients'],
            'clients_min_delay': load_cfg['client_min_wait'],
            'clients_max_delay': load_cfg['client_max_wait'],
            'get_root_requests_total': None,
            'get_root_requests_failures': None,
            'get_root_requests_median_response_time': None,
            'get_root_requests_average_response_time': None,
            'get_root_requests_minimum_response_time': None,
            'get_root_requests_maximum_response_time': None,
            'get_root_requests_rps': None,
            'get_cart_requests_total': None,
            'get_cart_requests_failures': None,
            'get_cart_requests_median_response_time': None,
            'get_cart_requests_average_response_time': None,
            'get_cart_requests_minimum_response_time': None,
            'get_cart_requests_maximum_response_time': None,
            'get_cart_requests_rps': None,
            'post_cart_requests_total': None,
            'post_cart_requests_failures': None,
            'post_cart_requests_median_response_time': None,
            'post_cart_requests_average_response_time': None,
            'post_cart_requests_minimum_response_time': None,
            'post_cart_requests_maximum_response_time': None,
            'post_cart_requests_rps': None,
            'get_products_requests_total': None,
            'get_products_requests_failures': None,
            'get_products_requests_median_response_time': None,
            'get_products_requests_average_response_time': None,
            'get_products_requests_minimum_response_time': None,
            'get_products_requests_maximum_response_time': None,
            'get_products_requests_rps': None,
            'post_setcurrency_requests_total': None,
            'post_setcurrency_requests_failures': None,
            'post_setcurrency_requests_median_response_time': None,
            'post_setcurrency_requests_average_response_time': None,
            'post_setcurrency_requests_minimum_response_time': None,
            'post_setcurrency_requests_maximum_response_time': None,
            'post_setcurrency_requests_rps': None,
            'total_requests_total': None,
            'total_requests_failures': None,
            'total_requests_median_response_time': None,
            'total_requests_average_response_time': None,
            'total_requests_minimum_response_time': None,
            'total_requests_maximum_response_time': None,
            'total_requests_rps': None,
            'get_root_percentile_50': None,
            'get_root_percentile_66': None,
            'get_root_percentile_75': None,
            'get_root_percentile_80': None,
            'get_root_percentile_90': None,
            'get_root_percentile_95': None,
            'get_root_percentile_98': None,
            'get_root_percentile_99': None,
            'get_root_percentile_100': None,
            'get_cart_percentile_50': None,
            'get_cart_percentile_66': None,
            'get_cart_percentile_75': None,
            'get_cart_percentile_80': None,
            'get_cart_percentile_90': None,
            'get_cart_percentile_95': None,
            'get_cart_percentile_98': None,
            'get_cart_percentile_99': None,
            'get_cart_percentile_100': None,
            'post_cart_percentile_50': None,
            'post_cart_percentile_66': None,
            'post_cart_percentile_75': None,
            'post_cart_percentile_80': None,
            'post_cart_percentile_90': None,
            'post_cart_percentile_95': None,
            'post_cart_percentile_98': None,
            'post_cart_percentile_99': None,
            'post_cart_percentile_100': None,
            'post_checkout_percentile_50': None,
            'post_checkout_percentile_66': None,
            'post_checkout_percentile_75': None,
            'post_checkout_percentile_80': None,
            'post_checkout_percentile_90': None,
            'post_checkout_percentile_95': None,
            'post_checkout_percentile_98': None,
            'post_checkout_percentile_99': None,
            'post_checkout_percentile_100': None,
            'get_products_percentile_50': None,
            'get_products_percentile_66': None,
            'get_products_percentile_75': None,
            'get_products_percentile_80': None,
            'get_products_percentile_90': None,
            'get_products_percentile_95': None,
            'get_products_percentile_98': None,
            'get_products_percentile_99': None,
            'get_products_percentile_100': None,
            'post_setcurrency_percentile_50': None,
            'post_setcurrency_percentile_66': None,
            'post_setcurrency_percentile_75': None,
            'post_setcurrency_percentile_80': None,
            'post_setcurrency_percentile_90': None,
            'post_setcurrency_percentile_95': None,
            'post_setcurrency_percentile_98': None,
            'post_setcurrency_percentile_99': None,
            'post_setcurrency_percentile_100': None,
            'total_percentile_50': None,
            'total_percentile_66': None,
            'total_percentile_75': None,
            'total_percentile_80': None,
            'total_percentile_90': None,
            'total_percentile_95': None,
            'total_percentile_98': None,
            'total_percentile_99': None,
            'total_percentile_100': None
        }

        requests_distributions = {}
        filename = 'locust_out_distribution.csv'
        with open(filename, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                requests_distributions_key = row['Name']
                requests_distributions[requests_distributions_key] = {}
                for key in row.keys():
                    requests_distributions[requests_distributions_key][key] = row[key]

        requests_stats = {}
        filename = 'locust_out_requests.csv'
        with open(filename, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                requests_stats_key = row['Method'] + ' '
                if requests_stats_key == 'None ': requests_stats_key = ''
                requests_stats_key = requests_stats_key + row['Name']
                requests_stats[requests_stats_key] = {}
                for key in row.keys():
                    requests_stats[requests_stats_key][key] = row[key]

        # Fill metrics
        for key in METRICS_MAP.keys():
            # fill percentiles
            for percentile in PERCENTILE_LIST:
                index = METRICS_MAP[key] + '_percentile_' + percentile
                try:
                    _metrics[index] = float(requests_distributions[key][percentile + '%'])
                except KeyError:
                    _metrics[index] = None

            # fill url stats
            for counter in COUNTERS_MAP.keys():
                index = METRICS_MAP[key] + '_requests_' + counter
                try:
                    _metrics[index] = float(requests_stats[key][COUNTERS_MAP[counter]])
                except KeyError:
                    _metrics[index] = None

        # Fill products (aggregated metrics)
        for key in requests_distributions.keys():
            if re.findall('/product/', key):
                for percentile in PERCENTILE_LIST:
                    if _metrics['get_products_percentile_' + percentile] is None:
                        _metrics['get_products_percentile_' + percentile] = float(requests_distributions[key][percentile + '%'])
                    else:
                        _metrics['get_products_percentile_' + percentile] += float(requests_distributions[key][percentile + '%'])

        # get_products_requests_average_response_time
        n = 0
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_average_response_time'] is None:
                    _metrics['get_products_requests_average_response_time'] = float(requests_stats[key][COUNTERS_MAP['average_response_time']])
                else:
                    _metrics['get_products_requests_average_response_time'] = _metrics['get_products_requests_average_response_time'] + \
                         (float(requests_stats[key][COUNTERS_MAP['average_response_time']]) - _metrics['get_products_requests_average_response_time']) / (n+1)
                n += 1

        # get_products_requests_failures
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_failures'] is None:
                    _metrics['get_products_requests_failures'] = int(requests_stats[key][COUNTERS_MAP['failures']])
                else:
                    _metrics['get_products_requests_failures'] += int(requests_stats[key][COUNTERS_MAP['failures']])

        # get_products_requests_maximum_response_time
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_maximum_response_time'] is None:
                    _metrics['get_products_requests_maximum_response_time'] = int(requests_stats[key][COUNTERS_MAP['maximum_response_time']])
                else:
                    _metrics['get_products_requests_maximum_response_time'] = max(int(requests_stats[key][COUNTERS_MAP['maximum_response_time']]), _metrics['get_products_requests_maximum_response_time'])

        # get_products_requests_minimum_response_time
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_minimum_response_time'] is None:
                    _metrics['get_products_requests_minimum_response_time'] = int(requests_stats[key][COUNTERS_MAP['minimum_response_time']])
                else:
                    _metrics['get_products_requests_minimum_response_time'] = min(int(requests_stats[key][COUNTERS_MAP['minimum_response_time']]), _metrics['get_products_requests_minimum_response_time'])

        # get_products_requests_rps
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_rps'] is None:
                    _metrics['get_products_requests_rps'] = float(requests_stats[key][COUNTERS_MAP['rps']])
                else:
                    _metrics['get_products_requests_rps'] += float(requests_stats[key][COUNTERS_MAP['rps']])

        # get_products_requests_total
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_total'] is None:
                    _metrics['get_products_requests_total'] = int(requests_stats[key][COUNTERS_MAP['total']])
                else:
                    _metrics['get_products_requests_total'] += int(requests_stats[key][COUNTERS_MAP['total']])

        # get_products_requests_median_response_time
        for key in requests_stats.keys():
            if re.findall('/product/', key):
                if _metrics['get_products_requests_median_response_time'] is None:
                    _metrics['get_products_requests_median_response_time'] = [int(requests_stats[key][COUNTERS_MAP['median_response_time']])]
                else:
                    _metrics['get_products_requests_median_response_time'].append(int(requests_stats[key][COUNTERS_MAP['median_response_time']]))
        if _metrics['get_products_requests_median_response_time'] is not None:
            _metrics['get_products_requests_median_response_time'] = statistics.median(_metrics['get_products_requests_median_response_time'])

        metrics = {}
        # TODO: if metrics were passed on input, only return those
        for metric_name in _metrics.keys():
            metrics[metric_name] = METRICS[metric_name].copy()
            metrics[metric_name]['value'] = _metrics[metric_name]

        annotations = {
            'command': command,
        }

        return (metrics, annotations)

    def _generate_locust_config(self, config):
        with open('locustfile.py.j2') as f:
            d = Template(f.read())

        with open('locustfile.py', 'w') as f:
            f.write(d.render(**config))


    # helper:  run apache benchmark measurement
    def _run_locust(self, test_url, test_scenario, n_clients, hatch_rate, n_requests, t_limit):

        prog_coefficient = 1.0
        prog_start = 0.0


        # construct and run measurement command
        # cmd = ['ab', '-l', '-c', str(n_threads)]
        cmd = ['locust', '-H', test_url, '-f', 'locustfile.py', '-c', str(n_clients), '-r', str(hatch_rate),
               '--csv=locust_out', '--no-web', '--reset-stats']
        if t_limit > 0:
            cmd.extend(['-t', str(t_limit)])
        try:
            os.unlink('locust_out_distribution.csv')
            os.unlink('locust_out_requests.csv')
        except FileNotFoundError:
            pass
        self._run_l_progress(cmd, 10000000, t_limit, prog_start, prog_coefficient)

        result = {}

        command = ' '.join(cmd)
        return (result, command)

    # helper:  execute apache benchmark command and print progress
    def _run_l_progress(self, cmd, n_requests, t_limit, prog_start, prog_coefficient):
        self.debug("Running test command:", cmd)
        self.proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # start progress for time limited ab command:  update every 5 seconds -
        # it is printed by default every 30 seconds
        if t_limit > 0:
            t_start = time.time()
            t = repeatingTimer(5, self._update_timed_progress, t_start, t_limit,
                               prog_start, prog_coefficient)
            t.start()

        # use try-and-finally to ensure the timer, if any, is canceled and does
        # not block driver exit in case of an exception
        try:

            # process stderr
            stderr = []
            with self.proc.stderr:
                for line in iter(self.proc.stderr.readline, b''):
                    l = line.decode().strip()
                    stderr.append(l)

            return_code = self.proc.wait()
        except Exception as e:
            raise
        finally:
            if t_limit > 0:
                t.cancel()

        # Never return Error
        # if return_code != 0:
        #     self.debug("Command failed. Stderr:\n" + '\n'.join(stderr))
        #     raise Exception("Failed to measure, Locust failed with exit code: " + str(return_code))

    # helper:  update timer based progress
    def _update_timed_progress(self, t_start, t_limit, prog_start, prog_coefficient):
        prog = min(100.0, 100.0 * (time.time() - t_start) / t_limit)
        self.progress = min(100, int((prog_coefficient * prog) + prog_start))


class repeatingTimer():
    def __init__(self, seconds, func, *args):
        self.seconds = seconds
        self.func = func
        self.args = args
        self.thread = Timer(self.seconds, self.call_func)
    def call_func(self):
        self.func(*self.args)
        self.thread = Timer(self.seconds, self.call_func)
        self.thread.start()
    def start(self):
        self.thread.start()
    def cancel(self):
        self.thread.cancel()


if __name__ == '__main__':
    l = L(VERSION, DESC, HAS_CANCEL, PROGRESS_INTERVAL)
    l.run()
